#ifndef SCENE_RENDERING_TOOLS_GLSLH
# define SCENE_RENDERING_TOOLS_GLSLH

/* ========================================================================== */
/*                                   OBJECTS                                  */
/* ========================================================================== */

// Data contained in VerticesData buffer.
struct VertexInput {
	uvec3	blockPos;
	uint	face;
	uint	layer;
	bool	isSideways;
};

// cf. block_properties.h
struct Block {
	vec3	worldPos;
	uint	type;
	uint	properties;
};

/* ========================================================================== */
/*                                  FUNCTIONS                                 */
/* ========================================================================== */

/* GENERAL ================================================================== */

// Sampler for chunks texture.
Block	getBlock(in uvec3 _blockPos, in uint _chunkId) {
	vec3 worldPos = vec3(_blockPos) + vec3(_chunkId * CHUNK_SIZE);

	float x_offsetted = float(_blockPos.x + (_blockPos.y % 4));
	float z_offsetted = float(_blockPos.z + (_blockPos.y / 4));
	vec3 uvw = vec3(x_offsetted, z_offsetted, _chunkId) / vec3(textureSize(chunks, 0));
	uvec2 blockRawData = texture(chunks, uvw).rg;

	return Block(worldPos, blockRawData.r, blockRawData.g);
}

/* CS ======================================================================= */

#ifdef CS

uint	packBlockPos(in uvec3 _pos) {
	return (_pos.x << 8) | (_pos.y << 4) | _pos.z;
}

#endif // CS

/* RS ======================================================================= */

#ifdef RS

// Unpacks VertexInput from vertices data buffer.
VertexInput	unpackVertexInput(in uint _packedInput) {
	VertexInput vertexInput;

	uint packedBlockPos = _packedInput >> 20;
	vertexInput.blockPos = uvec3(packedBlockPos >> 8,
						   packedBlockPos >> 4 & 0xF,
						   packedBlockPos & 0xF);

	vertexInput.face = (_packedInput >> 17) & 0x7;
	vertexInput.layer = (_packedInput >> 5) & 0xFFF;
	vertexInput.isSideways = bool((_packedInput >> 4) & 0x1);

	return vertexInput;
}

#endif // RS

/* ========================================================================== */



















#if 0
// Deprecated

int	isOutsideTexture(in ivec2 _pos) {
	if (_pos.x < 0 || _pos.y < 0)
		return -1;
	else if (_pos.x >= CHUNK_SIZE || _pos.y >= CHUNK_SIZE)
		return 1;
	return 0;
}

float	getHeight(in ivec2 _cubePos,in uint _layer) {
	// TODO: select proper layer
	int isOutside = isOutsideTexture(_cubePos);
	if (isOutside != 0)
		return 0.0;
	vec2 cubeUV = vec2(_cubePos) / vec2(textureSize(height_map, 0));
	return texture(height_map, vec3(cubeUV, _layer)).r;
}

// The vertices of a cube.
const vec3 vertices[36] = {
	// Top
	vec3(0.0, 1.0, 0.0),
	vec3(1.0, 1.0, 1.0),
	vec3(1.0, 1.0, 0.0),
	vec3(0.0, 1.0, 0.0),
	vec3(0.0, 1.0, 1.0),
	vec3(1.0, 1.0, 1.0),

	// Bottom
	vec3(1.0, 0.0, 0.0),
	vec3(0.0, 0.0, 1.0),
	vec3(0.0, 0.0, 0.0),
	vec3(1.0, 0.0, 0.0),
	vec3(1.0, 0.0, 1.0),
	vec3(0.0, 0.0, 1.0),

	// Left
	vec3(0.0, 0.0, 1.0),
	vec3(0.0, 1.0, 0.0),
	vec3(0.0, 0.0, 0.0),
	vec3(0.0, 0.0, 1.0),
	vec3(0.0, 1.0, 1.0),
	vec3(0.0, 1.0, 0.0),

	// Right
	vec3(1.0, 0.0, 0.0),
	vec3(1.0, 1.0, 1.0),
	vec3(1.0, 0.0, 1.0),
	vec3(1.0, 0.0, 0.0),
	vec3(1.0, 1.0, 0.0),
	vec3(1.0, 1.0, 1.0),

	// Front
	vec3(0.0, 0.0, 0.0),
	vec3(1.0, 1.0, 0.0),
	vec3(1.0, 0.0, 0.0),
	vec3(0.0, 0.0, 0.0),
	vec3(0.0, 1.0, 0.0),
	vec3(1.0, 1.0, 0.0),

	// Back
	vec3(1.0, 0.0, 1.0),
	vec3(0.0, 1.0, 1.0),
	vec3(0.0, 0.0, 1.0),
	vec3(1.0, 0.0, 1.0),
	vec3(1.0, 1.0, 1.0),
	vec3(0.0, 1.0, 1.0)
};

// Determine position of the vertex in the world.
vec4	extractPos(in uint _vertexId, in ivec2 _cubePos, in float _height, in ivec2 _chunkPos) {
	vec4 position = vec4(vertices[_vertexId], 1.0);

	position.xz += vec2((CHUNK_SIZE * _chunkPos) + _cubePos);
	position.y  += _height;

	return position;
}

bool	cullUnseenFace(in uint _face, in ivec2 _cubePos, in uint _instanceId, in float _cubeHeight) {
	ivec2	adjacentCubePos = ivec2(-1);
	if (_face == 2) {
		adjacentCubePos = ivec2(_cubePos.x - 1, _cubePos.y);
	} else if (_face == 3) {
		adjacentCubePos = ivec2(_cubePos.x + 1, _cubePos.y);
	} else if (_face == 4) {
		adjacentCubePos = ivec2(_cubePos.x, _cubePos.y - 1);
	} else if (_face == 5) {
		adjacentCubePos = ivec2(_cubePos.x, _cubePos.y + 1);
	} else {
		return false;
	}
	return getHeight(adjacentCubePos, _instanceId) >= _cubeHeight;
}

#endif // 0

#endif // SCENE_RENDERING_TOOLS_GLSLH