#ifndef TOOLS_GLSLH
# define TOOLS_GLSLH

/* ========================================================================== */
/*                                  INCLUDES                                  */
/* ========================================================================== */

#include "../../src/app/engine/gfx/renderers/culling/culling_consts.h"

/* ========================================================================== */
/*                                   OBJECTS                                  */
/* ========================================================================== */

// Data contained in QuadData buffer.
struct QuadInput {
	uvec3	blockUv;
	uint	face;
	uint	layer;
	bool	isSideways;
};

// cf. block_properties.h
struct Block {
	vec3	worldPos;
	uint	type;
	uint	properties;
	uint	visibleFaces; // bitmask (& 0x7)
};

/* ========================================================================== */
/*                                  FUNCTIONS                                 */
/* ========================================================================== */

/* GENERAL ================================================================== */

#ifdef CHUNKS

Block	getBlock(in uvec3 _blockUv, in uint _chunkLayer) {
	vec3 worldPos = vec3(_blockUv) + vec3(_chunkLayer * CHUNK_SIZE);

	float x_offsetted = float((_blockUv.x * 4) + (_blockUv.y % 4));
	float z_offsetted = float((_blockUv.z * 4) + (_blockUv.y / 4));
	vec3 uvw = vec3(
		vec2(x_offsetted, z_offsetted) / vec2(textureSize(chunks, 0)),
		_chunkLayer);
	uvec4 blockRawData = texture(chunks, uvw).rgba;

	return Block(worldPos, blockRawData.b, blockRawData.a, blockRawData.g);
}

#endif // CHUNKS

/* CS ======================================================================= */

#ifdef CS

// blockUv: 12 bit		-> to retrieve block type in `chunks` + block position
// face: 3 bits			-> to retrieve which face to sample
// layer: 12 bits		-> to retrieve which chunk to offset block position
// orientation: 1 bit	-> swap uv orientation for directed faces
// unused: 3 bits
uint	packQuadData(in uvec3 _blockUv, in uint _face, in uint _chunkLayer) {
	uint packed = (_blockUv.x << 8) | (_blockUv.y << 4) | _blockUv.z;
	packed = (packed << 3) | _face;
	packed = (packed << 12) | _chunkLayer;
	packed <<= 4;
	return packed;
}

#endif // CS

/* RS ======================================================================= */

#ifdef RS

// Unpacks QuadInput from packed quad data.
QuadInput	unpackQuadInput(in uint _packedInput) {
	QuadInput quadInput;

	uint packedBlockUv = _packedInput >> 20;
	quadInput.blockUv = uvec3(packedBlockUv >> 8,
							  packedBlockUv >> 4 & 0xF,
							  packedBlockUv & 0xF);

	quadInput.face = (_packedInput >> 17) & 0x7;

	uint packedLayer = _packedInput >> 5;
	uvec3 layer = uvec3(packedLayer >> 8,
						packedLayer >> 4 & 0xF,
						packedLayer & 0xF);
	quadInput.layer = (layer.x * RENDER_DISTANCE * RENDER_DISTANCE) +
					  (layer.y * RENDER_DISTANCE) +
					  (layer.z);

	quadInput.isSideways = bool((_packedInput >> 4) & 0x1);

	return quadInput;
}

QuadInput	_getQuadInput() {
	QuadInput	quadInput;

	uint 		quadIndex = 0;
	for (uint i = 0; i < TOTAL_CHUNKS; ++i) {
		uint newQuadIndex =  quadIndex + quadCount[i];
		if (gl_InstanceIndex < newQuadIndex) {
			unpackQuadInput(quadData[i][gl_InstanceIndex - quadIndex]);
			break;
		}
		quadIndex = newQuadIndex;
	}
	return quadInput;
}


#endif // RS

/* ========================================================================== */

#endif // TOOLS_GLSLH